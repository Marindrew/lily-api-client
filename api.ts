/* tslint:disable */
/* eslint-disable */
/**
 * simona-api
 * Booking System API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {number}
     * @memberof InlineObject
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    niNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    niNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    length?: number;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject11
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject11
     */
    system?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject12
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject12
     */
    system?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject14
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    day?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject14
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject15
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    day?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject15
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject16
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    day?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    endTime?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject16
     */
    userId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    customerId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    serviceId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject18
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject19
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    niNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject2
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    nameLt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    descriptionLt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    picture?: string;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject20
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    niNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject3
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    nameLt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    descriptionLt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    picture?: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject4
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject5
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    customerId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    serviceId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    customerId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    serviceId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    customerId?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    serviceId?: number;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject9
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    dt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject9
     */
    length?: number;
}

/**
 * BookingApi - axios parameter creator
 * @export
 */
export const BookingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingPost: async (data?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/booking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if you can a booking at this time
         * @summary Check if you can a booking at this time
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsFreeSlotsPost: async (data?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookings/free-slots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all bookings
         * @summary Find all bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel booking by id
         * @summary Cancel booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdCancelPost: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookingsIdCancelPost.');
            }
            const localVarPath = `/api/bookings/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete booking by id
         * @summary Delete booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookingsIdDelete.');
            }
            const localVarPath = `/api/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find booking by id
         * @summary Find booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookingsIdGet.');
            }
            const localVarPath = `/api/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a booking
         * @summary Update a booking
         * @param {number} id id of booking
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdPut: async (id: number, data?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookingsIdPut.');
            }
            const localVarPath = `/api/bookings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientTimesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find my bookings
         * @summary Find my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMyBookingsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/my-bookings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookingApi - functional programming interface
 * @export
 */
export const BookingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingPost(data?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Check if you can a booking at this time
         * @summary Check if you can a booking at this time
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsFreeSlotsPost(data?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsFreeSlotsPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find all bookings
         * @summary Find all bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cancel booking by id
         * @summary Cancel booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsIdCancelPost(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsIdCancelPost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete booking by id
         * @summary Delete booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find booking by id
         * @summary Find booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a booking
         * @summary Update a booking
         * @param {number} id id of booking
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookingsIdPut(id: number, data?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiBookingsIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientTimesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiClientTimesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find my bookings
         * @summary Find my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMyBookingsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookingApiAxiosParamCreator(configuration).apiMyBookingsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BookingApi - factory interface
 * @export
 */
export const BookingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingPost(data?: InlineObject7, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if you can a booking at this time
         * @summary Check if you can a booking at this time
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsFreeSlotsPost(data?: InlineObject8, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsFreeSlotsPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all bookings
         * @summary Find all bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsGet(options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel booking by id
         * @summary Cancel booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdCancelPost(id: number, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsIdCancelPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete booking by id
         * @summary Delete booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdDelete(id: number, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find booking by id
         * @summary Find booking by id
         * @param {number} id id of booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdGet(id: number, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a booking
         * @summary Update a booking
         * @param {number} id id of booking
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookingsIdPut(id: number, data?: InlineObject6, options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiBookingsIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientTimesGet(options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiClientTimesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Find my bookings
         * @summary Find my bookings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMyBookingsGet(options?: any): AxiosPromise<void> {
            return BookingApiFp(configuration).apiMyBookingsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookingApi - object-oriented interface
 * @export
 * @class BookingApi
 * @extends {BaseAPI}
 */
export class BookingApi extends BaseAPI {
    /**
     * Create a booking
     * @summary Create a booking
     * @param {InlineObject7} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingPost(data?: InlineObject7, options?: any) {
        return BookingApiFp(this.configuration).apiBookingPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if you can a booking at this time
     * @summary Check if you can a booking at this time
     * @param {InlineObject8} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsFreeSlotsPost(data?: InlineObject8, options?: any) {
        return BookingApiFp(this.configuration).apiBookingsFreeSlotsPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all bookings
     * @summary Find all bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsGet(options?: any) {
        return BookingApiFp(this.configuration).apiBookingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel booking by id
     * @summary Cancel booking by id
     * @param {number} id id of booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsIdCancelPost(id: number, options?: any) {
        return BookingApiFp(this.configuration).apiBookingsIdCancelPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete booking by id
     * @summary Delete booking by id
     * @param {number} id id of booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsIdDelete(id: number, options?: any) {
        return BookingApiFp(this.configuration).apiBookingsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find booking by id
     * @summary Find booking by id
     * @param {number} id id of booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsIdGet(id: number, options?: any) {
        return BookingApiFp(this.configuration).apiBookingsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a booking
     * @summary Update a booking
     * @param {number} id id of booking
     * @param {InlineObject6} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiBookingsIdPut(id: number, data?: InlineObject6, options?: any) {
        return BookingApiFp(this.configuration).apiBookingsIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find available dates for a client booking
     * @summary Find available dates for a client booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiClientTimesGet(options?: any) {
        return BookingApiFp(this.configuration).apiClientTimesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find my bookings
     * @summary Find my bookings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookingApi
     */
    public apiMyBookingsGet(options?: any) {
        return BookingApiFp(this.configuration).apiMyBookingsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookoutApi - axios parameter creator
 * @export
 */
export const BookoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a bookout
         * @summary Create a bookout
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutPost: async (data?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all bookouts
         * @summary Find all bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete bookout by id
         * @summary Delete bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookoutsIdDelete.');
            }
            const localVarPath = `/api/bookouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find bookout by id
         * @summary Find bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookoutsIdGet.');
            }
            const localVarPath = `/api/bookouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a bookout
         * @summary Update a bookout
         * @param {number} id id of bookout
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdPut: async (id: number, data?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiBookoutsIdPut.');
            }
            const localVarPath = `/api/bookouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find my bookouts
         * @summary Find my bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMyBookoutsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/my-bookouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookoutApi - functional programming interface
 * @export
 */
export const BookoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a bookout
         * @summary Create a bookout
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookoutPost(data?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiBookoutPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find all bookouts
         * @summary Find all bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookoutsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiBookoutsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete bookout by id
         * @summary Delete bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookoutsIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiBookoutsIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find bookout by id
         * @summary Find bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookoutsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiBookoutsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a bookout
         * @summary Update a bookout
         * @param {number} id id of bookout
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookoutsIdPut(id: number, data?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiBookoutsIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find my bookouts
         * @summary Find my bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMyBookoutsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BookoutApiAxiosParamCreator(configuration).apiMyBookoutsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BookoutApi - factory interface
 * @export
 */
export const BookoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a bookout
         * @summary Create a bookout
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutPost(data?: InlineObject10, options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiBookoutPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all bookouts
         * @summary Find all bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsGet(options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiBookoutsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete bookout by id
         * @summary Delete bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdDelete(id: number, options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiBookoutsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find bookout by id
         * @summary Find bookout by id
         * @param {number} id id of bookout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdGet(id: number, options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiBookoutsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a bookout
         * @summary Update a bookout
         * @param {number} id id of bookout
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookoutsIdPut(id: number, data?: InlineObject9, options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiBookoutsIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find my bookouts
         * @summary Find my bookouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMyBookoutsGet(options?: any): AxiosPromise<void> {
            return BookoutApiFp(configuration).apiMyBookoutsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookoutApi - object-oriented interface
 * @export
 * @class BookoutApi
 * @extends {BaseAPI}
 */
export class BookoutApi extends BaseAPI {
    /**
     * Create a bookout
     * @summary Create a bookout
     * @param {InlineObject10} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiBookoutPost(data?: InlineObject10, options?: any) {
        return BookoutApiFp(this.configuration).apiBookoutPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all bookouts
     * @summary Find all bookouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiBookoutsGet(options?: any) {
        return BookoutApiFp(this.configuration).apiBookoutsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete bookout by id
     * @summary Delete bookout by id
     * @param {number} id id of bookout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiBookoutsIdDelete(id: number, options?: any) {
        return BookoutApiFp(this.configuration).apiBookoutsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find bookout by id
     * @summary Find bookout by id
     * @param {number} id id of bookout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiBookoutsIdGet(id: number, options?: any) {
        return BookoutApiFp(this.configuration).apiBookoutsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a bookout
     * @summary Update a bookout
     * @param {number} id id of bookout
     * @param {InlineObject9} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiBookoutsIdPut(id: number, data?: InlineObject9, options?: any) {
        return BookoutApiFp(this.configuration).apiBookoutsIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find my bookouts
     * @summary Find my bookouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookoutApi
     */
    public apiMyBookoutsGet(options?: any) {
        return BookoutApiFp(this.configuration).apiMyBookoutsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if user is authorised
         * @summary Check if user is authorised
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientAuthGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientBookingCreatePost: async (data?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/booking/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientDatesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/dates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Check client activation code
         * @summary Check client activation code
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientMagicLinkCheckPost: async (data?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/magic-link/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send client a magic link
         * @summary Send client a magic link
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientMagicLinkPost: async (data?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new customer
         * @summary Register a new customer
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientRegisterPost: async (data?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find available services
         * @summary Find available services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientServicesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find available specialists for a client booking
         * @summary Find available specialists for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientSpecialistsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client/specialists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Check if user is authorised
         * @summary Check if user is authorised
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientAuthGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientAuthGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientBookingCreatePost(data?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientBookingCreatePost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientDatesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientDatesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Check client activation code
         * @summary Check client activation code
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientMagicLinkCheckPost(data?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientMagicLinkCheckPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send client a magic link
         * @summary Send client a magic link
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientMagicLinkPost(data?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientMagicLinkPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Register a new customer
         * @summary Register a new customer
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientRegisterPost(data?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientRegisterPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find available services
         * @summary Find available services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientServicesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientServicesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find available specialists for a client booking
         * @summary Find available specialists for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiClientSpecialistsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ClientApiAxiosParamCreator(configuration).apiClientSpecialistsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Check if user is authorised
         * @summary Check if user is authorised
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientAuthGet(options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientAuthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a booking
         * @summary Create a booking
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientBookingCreatePost(data?: InlineObject17, options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientBookingCreatePost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find available dates for a client booking
         * @summary Find available dates for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientDatesGet(options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientDatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check client activation code
         * @summary Check client activation code
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientMagicLinkCheckPost(data?: InlineObject20, options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientMagicLinkCheckPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Send client a magic link
         * @summary Send client a magic link
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientMagicLinkPost(data?: InlineObject19, options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientMagicLinkPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new customer
         * @summary Register a new customer
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientRegisterPost(data?: InlineObject18, options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientRegisterPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Find available services
         * @summary Find available services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientServicesGet(options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientServicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Find available specialists for a client booking
         * @summary Find available specialists for a client booking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiClientSpecialistsGet(options?: any): AxiosPromise<void> {
            return ClientApiFp(configuration).apiClientSpecialistsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * Check if user is authorised
     * @summary Check if user is authorised
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientAuthGet(options?: any) {
        return ClientApiFp(this.configuration).apiClientAuthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a booking
     * @summary Create a booking
     * @param {InlineObject17} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientBookingCreatePost(data?: InlineObject17, options?: any) {
        return ClientApiFp(this.configuration).apiClientBookingCreatePost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find available dates for a client booking
     * @summary Find available dates for a client booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientDatesGet(options?: any) {
        return ClientApiFp(this.configuration).apiClientDatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check client activation code
     * @summary Check client activation code
     * @param {InlineObject20} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientMagicLinkCheckPost(data?: InlineObject20, options?: any) {
        return ClientApiFp(this.configuration).apiClientMagicLinkCheckPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send client a magic link
     * @summary Send client a magic link
     * @param {InlineObject19} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientMagicLinkPost(data?: InlineObject19, options?: any) {
        return ClientApiFp(this.configuration).apiClientMagicLinkPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new customer
     * @summary Register a new customer
     * @param {InlineObject18} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientRegisterPost(data?: InlineObject18, options?: any) {
        return ClientApiFp(this.configuration).apiClientRegisterPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find available services
     * @summary Find available services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientServicesGet(options?: any) {
        return ClientApiFp(this.configuration).apiClientServicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find available specialists for a client booking
     * @summary Find available specialists for a client booking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiClientSpecialistsGet(options?: any) {
        return ClientApiFp(this.configuration).apiClientSpecialistsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find all customers
         * @summary Find all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete customer by id
         * @summary Delete customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiCustomersIdDelete.');
            }
            const localVarPath = `/api/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find customer by id
         * @summary Find customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiCustomersIdGet.');
            }
            const localVarPath = `/api/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer
         * @summary Update a customer
         * @param {number} id id of customer
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdPut: async (id: number, data?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiCustomersIdPut.');
            }
            const localVarPath = `/api/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Safely Delete customer by id (cleans account from GDPR info)
         * @summary Safely Delete customer by id (cleans account from GDPR info)
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdSafeDeleteDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiCustomersIdSafeDeleteDelete.');
            }
            const localVarPath = `/api/customers/{id}/safeDelete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a customer
         * @summary Create a customer
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersPost: async (data?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Customers users
         * @summary Customers users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersSearchGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/customers/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find all customers
         * @summary Find all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete customer by id
         * @summary Delete customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find customer by id
         * @summary Find customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a customer
         * @summary Update a customer
         * @param {number} id id of customer
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersIdPut(id: number, data?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Safely Delete customer by id (cleans account from GDPR info)
         * @summary Safely Delete customer by id (cleans account from GDPR info)
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersIdSafeDeleteDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersIdSafeDeleteDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a customer
         * @summary Create a customer
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersPost(data?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Customers users
         * @summary Customers users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomersSearchGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerApiAxiosParamCreator(configuration).apiCustomersSearchGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find all customers
         * @summary Find all customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersGet(options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete customer by id
         * @summary Delete customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdDelete(id: number, options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find customer by id
         * @summary Find customer by id
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdGet(id: number, options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a customer
         * @summary Update a customer
         * @param {number} id id of customer
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdPut(id: number, data?: InlineObject5, options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Safely Delete customer by id (cleans account from GDPR info)
         * @summary Safely Delete customer by id (cleans account from GDPR info)
         * @param {number} id id of customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersIdSafeDeleteDelete(id: number, options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersIdSafeDeleteDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a customer
         * @summary Create a customer
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersPost(data?: InlineObject4, options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Customers users
         * @summary Customers users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomersSearchGet(options?: any): AxiosPromise<void> {
            return CustomerApiFp(configuration).apiCustomersSearchGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Find all customers
     * @summary Find all customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersGet(options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete customer by id
     * @summary Delete customer by id
     * @param {number} id id of customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersIdDelete(id: number, options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find customer by id
     * @summary Find customer by id
     * @param {number} id id of customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersIdGet(id: number, options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a customer
     * @summary Update a customer
     * @param {number} id id of customer
     * @param {InlineObject5} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersIdPut(id: number, data?: InlineObject5, options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Safely Delete customer by id (cleans account from GDPR info)
     * @summary Safely Delete customer by id (cleans account from GDPR info)
     * @param {number} id id of customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersIdSafeDeleteDelete(id: number, options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersIdSafeDeleteDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a customer
     * @summary Create a customer
     * @param {InlineObject4} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersPost(data?: InlineObject4, options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Customers users
     * @summary Customers users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public apiCustomersSearchGet(options?: any) {
        return CustomerApiFp(this.configuration).apiCustomersSearchGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request magic link to the email
         * @summary Request magic link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMagicLinkPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/magic-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange magic link for a token
         * @summary Welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Request magic link to the email
         * @summary Request magic link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMagicLinkPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GeneralApiAxiosParamCreator(configuration).apiMagicLinkPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Exchange magic link for a token
         * @summary Welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GeneralApiAxiosParamCreator(configuration).apiTokenGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Request magic link to the email
         * @summary Request magic link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMagicLinkPost(options?: any): AxiosPromise<void> {
            return GeneralApiFp(configuration).apiMagicLinkPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange magic link for a token
         * @summary Welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenGet(options?: any): AxiosPromise<void> {
            return GeneralApiFp(configuration).apiTokenGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
    /**
     * Request magic link to the email
     * @summary Request magic link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public apiMagicLinkPost(options?: any) {
        return GeneralApiFp(this.configuration).apiMagicLinkPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange magic link for a token
     * @summary Welcome page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public apiTokenGet(options?: any) {
        return GeneralApiFp(this.configuration).apiTokenGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HolidayApi - axios parameter creator
 * @export
 */
export const HolidayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets holidays
         * @summary Gets holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHolidaysGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/holidays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HolidayApi - functional programming interface
 * @export
 */
export const HolidayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets holidays
         * @summary Gets holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHolidaysGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HolidayApiAxiosParamCreator(configuration).apiHolidaysGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HolidayApi - factory interface
 * @export
 */
export const HolidayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets holidays
         * @summary Gets holidays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHolidaysGet(options?: any): AxiosPromise<void> {
            return HolidayApiFp(configuration).apiHolidaysGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HolidayApi - object-oriented interface
 * @export
 * @class HolidayApi
 * @extends {BaseAPI}
 */
export class HolidayApi extends BaseAPI {
    /**
     * Gets holidays
     * @summary Gets holidays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HolidayApi
     */
    public apiHolidaysGet(options?: any) {
        return HolidayApiFp(this.configuration).apiHolidaysGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HourApi - axios parameter creator
 * @export
 */
export const HourApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find hour by id
         * @summary Find hour by id
         * @param {number} id id of hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiHoursIdGet.');
            }
            const localVarPath = `/api/hours/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an hour
         * @summary Update an hour
         * @param {number} id id of hour
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursIdPut: async (id: number, data?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiHoursIdPut.');
            }
            const localVarPath = `/api/hours/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a hour
         * @summary Create a hour
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursPost: async (data?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create hours
         * @summary Create hours
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursPut: async (data?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search hours
         * @summary Search hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursSearchGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hours/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HourApi - functional programming interface
 * @export
 */
export const HourApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find hour by id
         * @summary Find hour by id
         * @param {number} id id of hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHoursIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HourApiAxiosParamCreator(configuration).apiHoursIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an hour
         * @summary Update an hour
         * @param {number} id id of hour
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHoursIdPut(id: number, data?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HourApiAxiosParamCreator(configuration).apiHoursIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a hour
         * @summary Create a hour
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHoursPost(data?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HourApiAxiosParamCreator(configuration).apiHoursPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create hours
         * @summary Create hours
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHoursPut(data?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HourApiAxiosParamCreator(configuration).apiHoursPut(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search hours
         * @summary Search hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHoursSearchGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HourApiAxiosParamCreator(configuration).apiHoursSearchGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HourApi - factory interface
 * @export
 */
export const HourApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find hour by id
         * @summary Find hour by id
         * @param {number} id id of hour
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursIdGet(id: number, options?: any): AxiosPromise<void> {
            return HourApiFp(configuration).apiHoursIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an hour
         * @summary Update an hour
         * @param {number} id id of hour
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursIdPut(id: number, data?: InlineObject14, options?: any): AxiosPromise<void> {
            return HourApiFp(configuration).apiHoursIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a hour
         * @summary Create a hour
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursPost(data?: InlineObject16, options?: any): AxiosPromise<void> {
            return HourApiFp(configuration).apiHoursPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create hours
         * @summary Create hours
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursPut(data?: InlineObject15, options?: any): AxiosPromise<void> {
            return HourApiFp(configuration).apiHoursPut(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Search hours
         * @summary Search hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHoursSearchGet(options?: any): AxiosPromise<void> {
            return HourApiFp(configuration).apiHoursSearchGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HourApi - object-oriented interface
 * @export
 * @class HourApi
 * @extends {BaseAPI}
 */
export class HourApi extends BaseAPI {
    /**
     * Find hour by id
     * @summary Find hour by id
     * @param {number} id id of hour
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HourApi
     */
    public apiHoursIdGet(id: number, options?: any) {
        return HourApiFp(this.configuration).apiHoursIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an hour
     * @summary Update an hour
     * @param {number} id id of hour
     * @param {InlineObject14} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HourApi
     */
    public apiHoursIdPut(id: number, data?: InlineObject14, options?: any) {
        return HourApiFp(this.configuration).apiHoursIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a hour
     * @summary Create a hour
     * @param {InlineObject16} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HourApi
     */
    public apiHoursPost(data?: InlineObject16, options?: any) {
        return HourApiFp(this.configuration).apiHoursPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create hours
     * @summary Create hours
     * @param {InlineObject15} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HourApi
     */
    public apiHoursPut(data?: InlineObject15, options?: any) {
        return HourApiFp(this.configuration).apiHoursPut(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search hours
     * @summary Search hours
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HourApi
     */
    public apiHoursSearchGet(options?: any) {
        return HourApiFp(this.configuration).apiHoursSearchGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete service by id
         * @summary Delete service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiServiceIdDelete.');
            }
            const localVarPath = `/api/service/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all services
         * @summary Find all services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find service by id
         * @summary Find service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiServicesIdGet.');
            }
            const localVarPath = `/api/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a service
         * @summary Update a service
         * @param {number} id id of service
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesIdPut: async (id: number, data?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiServicesIdPut.');
            }
            const localVarPath = `/api/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a service
         * @summary Create a service
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesPost: async (data?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search services
         * @summary Search services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesSearchGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/services/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete service by id
         * @summary Delete service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServiceIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServiceIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find all services
         * @summary Find all services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServicesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServicesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find service by id
         * @summary Find service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServicesIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServicesIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a service
         * @summary Update a service
         * @param {number} id id of service
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServicesIdPut(id: number, data?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServicesIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a service
         * @summary Create a service
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServicesPost(data?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServicesPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search services
         * @summary Search services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServicesSearchGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServiceApiAxiosParamCreator(configuration).apiServicesSearchGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete service by id
         * @summary Delete service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServiceIdDelete(id: number, options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServiceIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all services
         * @summary Find all services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesGet(options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Find service by id
         * @summary Find service by id
         * @param {number} id id of service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesIdGet(id: number, options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServicesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a service
         * @summary Update a service
         * @param {number} id id of service
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesIdPut(id: number, data?: InlineObject3, options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServicesIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a service
         * @summary Create a service
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesPost(data?: InlineObject2, options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServicesPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Search services
         * @summary Search services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServicesSearchGet(options?: any): AxiosPromise<void> {
            return ServiceApiFp(configuration).apiServicesSearchGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * Delete service by id
     * @summary Delete service by id
     * @param {number} id id of service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServiceIdDelete(id: number, options?: any) {
        return ServiceApiFp(this.configuration).apiServiceIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all services
     * @summary Find all services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicesGet(options?: any) {
        return ServiceApiFp(this.configuration).apiServicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find service by id
     * @summary Find service by id
     * @param {number} id id of service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicesIdGet(id: number, options?: any) {
        return ServiceApiFp(this.configuration).apiServicesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a service
     * @summary Update a service
     * @param {number} id id of service
     * @param {InlineObject3} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicesIdPut(id: number, data?: InlineObject3, options?: any) {
        return ServiceApiFp(this.configuration).apiServicesIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a service
     * @summary Create a service
     * @param {InlineObject2} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicesPost(data?: InlineObject2, options?: any) {
        return ServiceApiFp(this.configuration).apiServicesPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search services
     * @summary Search services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public apiServicesSearchGet(options?: any) {
        return ServiceApiFp(this.configuration).apiServicesSearchGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingApi - axios parameter creator
 * @export
 */
export const SettingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find all settings
         * @summary Find all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get integration javascript
         * @summary Get integration javascript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsIntegrationGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/settings/integration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a settings
         * @summary Update a settings
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsPost: async (data?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingApi - functional programming interface
 * @export
 */
export const SettingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Find all settings
         * @summary Find all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSettingsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingApiAxiosParamCreator(configuration).apiSettingsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get integration javascript
         * @summary Get integration javascript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSettingsIntegrationGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingApiAxiosParamCreator(configuration).apiSettingsIntegrationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a settings
         * @summary Update a settings
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSettingsPost(data?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SettingApiAxiosParamCreator(configuration).apiSettingsPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingApi - factory interface
 * @export
 */
export const SettingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Find all settings
         * @summary Find all settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsGet(options?: any): AxiosPromise<void> {
            return SettingApiFp(configuration).apiSettingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get integration javascript
         * @summary Get integration javascript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsIntegrationGet(options?: any): AxiosPromise<void> {
            return SettingApiFp(configuration).apiSettingsIntegrationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a settings
         * @summary Update a settings
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSettingsPost(data?: InlineObject13, options?: any): AxiosPromise<void> {
            return SettingApiFp(configuration).apiSettingsPost(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingApi - object-oriented interface
 * @export
 * @class SettingApi
 * @extends {BaseAPI}
 */
export class SettingApi extends BaseAPI {
    /**
     * Find all settings
     * @summary Find all settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public apiSettingsGet(options?: any) {
        return SettingApiFp(this.configuration).apiSettingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get integration javascript
     * @summary Get integration javascript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public apiSettingsIntegrationGet(options?: any) {
        return SettingApiFp(this.configuration).apiSettingsIntegrationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a settings
     * @summary Update a settings
     * @param {InlineObject13} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingApi
     */
    public apiSettingsPost(data?: InlineObject13, options?: any) {
        return SettingApiFp(this.configuration).apiSettingsPost(data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete tag by id
         * @summary Delete tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagIdDelete.');
            }
            const localVarPath = `/api/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search tags
         * @summary Search tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find tag by id
         * @summary Find tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagsIdGet.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tag
         * @summary Update a tag
         * @param {number} id id of tag
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdPut: async (id: number, data?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiTagsIdPut.');
            }
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost: async (data?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete tag by id
         * @summary Delete tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).apiTagIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search tags
         * @summary Search tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).apiTagsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find tag by id
         * @summary Find tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagsIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).apiTagsIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a tag
         * @summary Update a tag
         * @param {number} id id of tag
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagsIdPut(id: number, data?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).apiTagsIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagsPost(data?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).apiTagsPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete tag by id
         * @summary Delete tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagIdDelete(id: number, options?: any): AxiosPromise<void> {
            return TagApiFp(configuration).apiTagIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Search tags
         * @summary Search tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsGet(options?: any): AxiosPromise<void> {
            return TagApiFp(configuration).apiTagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Find tag by id
         * @summary Find tag by id
         * @param {number} id id of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdGet(id: number, options?: any): AxiosPromise<void> {
            return TagApiFp(configuration).apiTagsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tag
         * @summary Update a tag
         * @param {number} id id of tag
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsIdPut(id: number, data?: InlineObject12, options?: any): AxiosPromise<void> {
            return TagApiFp(configuration).apiTagsIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a tag
         * @summary Create a tag
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagsPost(data?: InlineObject11, options?: any): AxiosPromise<void> {
            return TagApiFp(configuration).apiTagsPost(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * Delete tag by id
     * @summary Delete tag by id
     * @param {number} id id of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagIdDelete(id: number, options?: any) {
        return TagApiFp(this.configuration).apiTagIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search tags
     * @summary Search tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagsGet(options?: any) {
        return TagApiFp(this.configuration).apiTagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find tag by id
     * @summary Find tag by id
     * @param {number} id id of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagsIdGet(id: number, options?: any) {
        return TagApiFp(this.configuration).apiTagsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tag
     * @summary Update a tag
     * @param {number} id id of tag
     * @param {InlineObject12} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagsIdPut(id: number, data?: InlineObject12, options?: any) {
        return TagApiFp(this.configuration).apiTagsIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a tag
     * @summary Create a tag
     * @param {InlineObject11} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagsPost(data?: InlineObject11, options?: any) {
        return TagApiFp(this.configuration).apiTagsPost(data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete users generated by integration and load tests
         * @summary Delete users generated by integration and load tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTestusersDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/testusers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all users
         * @summary Find all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user by id
         * @summary Delete user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdDelete.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Find user by id
         * @summary Find user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdGet.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user
         * @summary Update a user
         * @param {number} id id of user
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut: async (id: number, data?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling apiUsersIdPut.');
            }
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user
         * @summary Create a user
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost: async (data?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof data !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(data !== undefined ? data : {})
                : (data || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Search users
         * @summary Search users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersSearchGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete users generated by integration and load tests
         * @summary Delete users generated by integration and load tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTestusersDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiTestusersDelete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find all users
         * @summary Find all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete user by id
         * @summary Delete user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersIdDelete(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Find user by id
         * @summary Find user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersIdGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a user
         * @summary Update a user
         * @param {number} id id of user
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPut(id: number, data?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersIdPut(id, data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a user
         * @summary Create a user
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersPost(data?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersPost(data, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search users
         * @summary Search users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersSearchGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUsersSearchGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete users generated by integration and load tests
         * @summary Delete users generated by integration and load tests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTestusersDelete(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiTestusersDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Find all users
         * @summary Find all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user by id
         * @summary Delete user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find user by id
         * @summary Find user by id
         * @param {number} id id of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: number, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user
         * @summary Update a user
         * @param {number} id id of user
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPut(id: number, data?: InlineObject1, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersIdPut(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user
         * @summary Create a user
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(data?: InlineObject, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersPost(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Search users
         * @summary Search users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersSearchGet(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUsersSearchGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Delete users generated by integration and load tests
     * @summary Delete users generated by integration and load tests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiTestusersDelete(options?: any) {
        return UserApiFp(this.configuration).apiTestusersDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all users
     * @summary Find all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersGet(options?: any) {
        return UserApiFp(this.configuration).apiUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user by id
     * @summary Delete user by id
     * @param {number} id id of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdDelete(id: number, options?: any) {
        return UserApiFp(this.configuration).apiUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find user by id
     * @summary Find user by id
     * @param {number} id id of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: number, options?: any) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user
     * @summary Update a user
     * @param {number} id id of user
     * @param {InlineObject1} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPut(id: number, data?: InlineObject1, options?: any) {
        return UserApiFp(this.configuration).apiUsersIdPut(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user
     * @summary Create a user
     * @param {InlineObject} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersPost(data?: InlineObject, options?: any) {
        return UserApiFp(this.configuration).apiUsersPost(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search users
     * @summary Search users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersSearchGet(options?: any) {
        return UserApiFp(this.configuration).apiUsersSearchGet(options).then((request) => request(this.axios, this.basePath));
    }
}


